# MyRPC 手写轻量级分布式 RPC 框架
本项目技术栈：Spring + Maven + Netty + Zookeeper + Protostuff 

## 一 RPC 框架架构设计

RPC 又称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。通俗地讲，就是开发者能够像调用本地方法一样调用远程的服务。

![1688103229480](README.assets/1688103229480.png)

- 服务端在启动后，会将它提供的服务列表发布到注册中心，客户端向注册中心订阅服务地址；
- 客户端会通过本地代理模块 Proxy 调用服务端，Proxy 模块收到负责将方法、参数等数据转化成网络字节流；
- 客户端从服务列表中选取其中一个的服务地址，并将数据通过网络发送给服务端；
- 服务端接收到数据后进行解码，得到请求信息；
- 服务端根据解码后的请求信息调用对应的服务，然后将调用结果返回给客户端。

## 二 模块概览

本框架的核心功能模块:
rpc-common:包含封装RPC请求与响应的消息体，Netty编解码器codec以及基于Protostuff实现的序列化/反序列功能
rpc-server : RPC服务端，接收客户端的请求和消息体，处理并响应客户端的请求/消息体
rpc-client : RPC客户端，向服务端发送请求和消息体，接收服务端的响应。
rpc-registry :基于Zookeeper 及其客户端ZkClient 实现服务的注册与发现

## 三 技术选型

**1 注册中心**

本实现中支持了注册中心Zookeeper。

1. 高可用性：ZooKeeper 是一个高可用的分布式协调服务，它使用了分布式一致性算法（ZAB）来保证数据的一致性和可用性。它采用主从模式，在多个服务器上复制数据，并提供自动的故障恢复机制。这使得 ZooKeeper 具有很高的可用性，可以支持关键的服务注册和发现功能。
2. 数据一致性：ZooKeeper 提供强一致性的数据模型，保证注册中心中的数据始终保持一致。所有的写入操作都会被顺序化，并通过多数投票机制来保证数据的一致性。这对于分布式系统中的服务注册和发现非常重要，可以避免脑裂和数据不一致的问题。
3. 高性能：ZooKeeper 具有较高的性能，能够处理大规模的并发请求。它使用内存数据库来存储数据，并采用了多级缓存机制，以提高读写操作的性能。此外，ZooKeeper 还支持批量操作和异步操作，可以进一步提升性能。
4. 灵活性：ZooKeeper 提供了灵活的数据模型和编程接口，可以支持各种类型的注册和发现需求。它提供了节点的层次结构（类似于文件系统），可以创建临时节点、持久节点和顺序节点等。这样可以根据具体的应用场景来设计和管理服务注册和发现的结构。
5. 成熟稳定：ZooKeeper 是一个经过多年发展和广泛应用的成熟项目，已经在许多大型分布式系统中得到验证。它具有稳定的稳定性和可靠性，有活跃的社区支持和持续的更新和改进。

**2 IO通信框架**

本实现采用Netty作为底层通信框架，Netty是一个高性能事件驱动型的非阻塞的IO(NIO)框架。

1. 高性能：Netty 是一个基于 Java 的高性能网络通信框架，它通过使用异步、事件驱动的模型来实现高并发和低延迟的通信。它利用了非阻塞 I/O 和多线程池等技术，能够处理大量的并发连接和高吞吐量的数据传输。
2. 可扩展性：Netty 的设计考虑了可扩展性，它提供了灵活的组件模型和扩展点，使得开发人员可以根据需要定制和扩展各个层次的功能。它的事件驱动模型和多线程池机制也使得它能够适应高并发和大规模的系统需求。
3. 异步非阻塞：Netty 使用了异步非阻塞的 I/O 模型，避免了传统阻塞 I/O 模型中线程阻塞的问题，提高了系统的并发性能。它利用了 Java NIO（New I/O）库，可以高效地处理并发连接，减少线程的创建和管理开销。
4. 协议支持：Netty 提供了丰富的协议支持，包括 HTTP、WebSocket、TCP、UDP 等。它提供了一些内置的编解码器和处理器，简化了协议的处理和开发工作。开发人员可以使用这些组件来快速构建和处理各种类型的协议。
5. 社区活跃：Netty 拥有一个活跃的社区，有大量的用户和开发者在使用和贡献代码。这意味着可以获得及时的技术支持、文档资源和社区贡献的优化和改进，使得开发工作更加便利和可靠。

**3 通信协议**

TCP通信过程中会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。所以需要对发送的数据包封装到一种通信协议里。

业界的主流协议的解决方案可以归纳如下：

1. 消息定长，例如每个报文的大小为固定长度100字节，如果不够用空格补足。
2. 在包尾特殊结束符进行分割。
3. 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。

很明显1，2都有些局限性，本实现采用方案3，具体协议设计如下：

```text
+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+ 
|  BYTE  |        |        |        |        |        |        |             ........ 
+--------------------------------------------+--------+-----------------+--------+--------+--------+--------+--------+--------+-----------------+ 
|            content lenth           |                   content byte[]                  |
+--------+-----------------------------------------------------------------------------------------+--------------------------------------------+
```

- 第一部分是消息头，表示消息长度，占四个字节
- 第二部分是消息内容content。

**4 序列化协议**

本实现采用了Protostuff，有以下几个优点。

1. 高效性能：Protostuff 在序列化和反序列化方面具有出色的性能。它使用了基于代码生成的技术，将 Java 对象转换为紧凑的二进制格式，以提高序列化和反序列化的速度。相比其他一些序列化框架，Protostuff 的性能表现通常更好。
2. 紧凑的数据格式：Protostuff 生成的二进制格式非常紧凑，占用较少的存储空间。这对于在网络传输和持久化存储中节省带宽和存储资源非常有用。紧凑的数据格式还可以提高数据的传输效率和响应速度。
3. 低延迟：由于 Protostuff 的高性能和紧凑的数据格式，它可以实现较低的序列化和反序列化延迟。这对于需要快速处理大量数据的应用程序特别有用，如高吞吐量的分布式系统或实时流处理系统。
4. 简单易用：Protostuff 的 API 设计简单直观，易于使用和理解。它提供了用于序列化和反序列化的注解和工具，使开发人员可以方便地在他们的 Java 类上定义序列化规则。

**5 负载均衡**

本实现支持随机负载均衡策略，有以下几个优点。

1. 简单易实现：随机负载均衡算法非常简单，实现起来较为容易。它不需要对服务的状态或负载进行复杂的监控和计算，只需从可用的服务列表中随机选择一个即可。
2. 均衡负载：随机算法可以实现基本的负载均衡，因为每次选择都是随机的，各个服务节点有相等的机会被选中。这样可以避免出现某些节点过载而其他节点空闲的情况，提高了系统整体的性能和资源利用率。
3. 无需服务状态监控：相比其他负载均衡算法如加权轮询或最小连接数，随机负载均衡算法不需要对服务节点的状态进行监控和统计。这降低了实现和维护的复杂性，减少了对系统的额外负载。